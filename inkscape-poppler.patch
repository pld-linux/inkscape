From a600c6438fef2f4c06f9a4a7d933d99fb054a973 Mon Sep 17 00:00:00 2001
From: Eduard Braun <eduard.braun2@gmx.de>
Date: Tue, 24 Apr 2018 19:18:26 +0200
Subject: [PATCH] Fix compilation with poppler 0.64

---
 src/extension/internal/pdfinput/pdf-parser.cpp  | 10 +++++-----
 src/extension/internal/pdfinput/pdf-parser.h    |  2 +-
 src/extension/internal/pdfinput/svg-builder.cpp |  4 ++--
 src/extension/internal/pdfinput/svg-builder.h   |  3 +--
 4 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/src/extension/internal/pdfinput/pdf-parser.cpp b/src/extension/internal/pdfinput/pdf-parser.cpp
index 15bc2d746d..6c498f9812 100644
--- a/src/extension/internal/pdfinput/pdf-parser.cpp
+++ b/src/extension/internal/pdfinput/pdf-parser.cpp
@@ -2582,7 +2582,7 @@ void PdfParser::opShowSpaceText(Object args[], int /*numArgs*/)
   }
 }
 
-void PdfParser::doShowText(GooString *s) {
+void PdfParser::doShowText(const GooString *s) {
   GfxFont *font;
   int wMode;
   double riseX, riseY;
@@ -2601,7 +2601,7 @@ void PdfParser::doShowText(GooString *s) {
   font = state->getFont();
   wMode = font->getWMode();
 
-  builder->beginString(state, s);
+  builder->beginString(state);
 
   // handle a Type 3 char
   if (font->getType() == fontType3 && 0) {//out->interpretType3Chars()) {
@@ -2631,7 +2631,7 @@ void PdfParser::doShowText(GooString *s) {
     double lineX = state->getLineX();
     double lineY = state->getLineY();
     oldParser = parser;
-    p = s->getCString();
+    p = g_strdup(s->getCString());
     len = s->getLength();
     while (len > 0) {
       n = font->getNextChar(p, len, &code,
@@ -2686,7 +2686,7 @@ void PdfParser::doShowText(GooString *s) {
 
   } else {
     state->textTransformDelta(0, state->getRise(), &riseX, &riseY);
-    p = s->getCString();
+    p = g_strdup(s->getCString());
     len = s->getLength();
     while (len > 0) {
       n = font->getNextChar(p, len, &code,
@@ -2732,7 +2732,7 @@ void PdfParser::opXObject(Object args[], int /*numArgs*/)
 {
   Object obj1, obj2, obj3, refObj;
 
-  char *name = args[0].getName();
+  char *name = g_strdup(args[0].getName());
 #if defined(POPPLER_NEW_OBJECT_API)
   if ((obj1 = res->lookupXObject(name)).isNull()) {
 #else
diff --git a/src/extension/internal/pdfinput/pdf-parser.h b/src/extension/internal/pdfinput/pdf-parser.h
index e28fecc2e1..f985b15cad 100644
--- a/src/extension/internal/pdfinput/pdf-parser.h
+++ b/src/extension/internal/pdfinput/pdf-parser.h
@@ -287,7 +287,7 @@ private:
   void opMoveShowText(Object args[], int numArgs);
   void opMoveSetShowText(Object args[], int numArgs);
   void opShowSpaceText(Object args[], int numArgs);
-  void doShowText(GooString *s);
+  void doShowText(const GooString *s);
 
   // XObject operators
   void opXObject(Object args[], int numArgs);
diff --git a/src/extension/internal/pdfinput/svg-builder.cpp b/src/extension/internal/pdfinput/svg-builder.cpp
index 158c5ae068..8e5a5f6396 100644
--- a/src/extension/internal/pdfinput/svg-builder.cpp
+++ b/src/extension/internal/pdfinput/svg-builder.cpp
@@ -1021,7 +1021,7 @@ void SvgBuilder::updateFont(GfxState *state) {
     GfxFont *font = state->getFont();
     // Store original name
     if (font->getName()) {
-        _font_specification = font->getName()->getCString();
+        _font_specification = g_strdup(font->getName()->getCString());
     } else {
         _font_specification = (char*) "Arial";
     }
@@ -1362,7 +1362,7 @@ void SvgBuilder::_flushText() {
     _glyphs.clear();
 }
 
-void SvgBuilder::beginString(GfxState *state, GooString * /*s*/) {
+void SvgBuilder::beginString(GfxState *state) {
     if (_need_font_update) {
         updateFont(state);
     }
diff --git a/src/extension/internal/pdfinput/svg-builder.h b/src/extension/internal/pdfinput/svg-builder.h
index ad15c9c06f..ed2a4d48e0 100644
--- a/src/extension/internal/pdfinput/svg-builder.h
+++ b/src/extension/internal/pdfinput/svg-builder.h
@@ -29,7 +29,6 @@ namespace Inkscape {
 #include <glibmm/ustring.h>
 
 #include "CharTypes.h"
-class GooString;
 class Function;
 class GfxState;
 struct GfxColor;
@@ -136,7 +135,7 @@ public:
     void clearSoftMask(GfxState *state);
 
     // Text handling
-    void beginString(GfxState *state, GooString *s);
+    void beginString(GfxState *state);
     void endString(GfxState *state);
     void addChar(GfxState *state, double x, double y,
                  double dx, double dy,
-- 
2.18.1

From 722e121361d0f784083d10e897155b7d4e44e515 Mon Sep 17 00:00:00 2001
From: Eduard Braun <eduard.braun2@gmx.de>
Date: Wed, 5 Sep 2018 00:31:06 +0200
Subject: [PATCH] Modified fix for compatibility with poppler 0.64

This is slightly uglier than a600c6438fef2f4c06f9a4a7d933d99fb054a973
but avoids duplicating strings (which is unnecessary and leaked memory).

It's also closer to what upstream intended with the changes in 0.64.
---
 .../internal/pdfinput/pdf-parser.cpp          | 19 ++++++++++++++++---
 src/extension/internal/pdfinput/pdf-parser.h  |  6 ++++++
 .../internal/pdfinput/svg-builder.cpp         |  6 +++---
 src/extension/internal/pdfinput/svg-builder.h |  4 ++--
 4 files changed, 27 insertions(+), 8 deletions(-)

diff --git a/src/extension/internal/pdfinput/pdf-parser.cpp b/src/extension/internal/pdfinput/pdf-parser.cpp
index 5fa21263ab..a3a8ff25a6 100644
--- a/src/extension/internal/pdfinput/pdf-parser.cpp
+++ b/src/extension/internal/pdfinput/pdf-parser.cpp
@@ -32,6 +32,7 @@
 #include "pdf-parser.h"
 #include "util/units.h"
 
+#include "glib/poppler-features.h"
 #include "goo/gmem.h"
 #include "goo/GooString.h"
 #include "GlobalParams.h"
@@ -2577,7 +2578,11 @@ void PdfParser::opShowSpaceText(Object args[], int /*numArgs*/)
   }
 }
 
+#if POPPLER_CHECK_VERSION(0,64,0)
 void PdfParser::doShowText(const GooString *s) {
+#else
+void PdfParser::doShowText(GooString *s) {
+#endif
   GfxFont *font;
   int wMode;
   double riseX, riseY;
@@ -2590,7 +2595,11 @@ void PdfParser::doShowText(const GooString *s) {
   Object charProc;
   Dict *resDict;
   Parser *oldParser;
+#if POPPLER_CHECK_VERSION(0,64,0)
+  const char *p;
+#else
   char *p;
+#endif
   int len, n, uLen;
 
   font = state->getFont();
@@ -2626,7 +2635,7 @@ void PdfParser::doShowText(const GooString *s) {
     double lineX = state->getLineX();
     double lineY = state->getLineY();
     oldParser = parser;
-    p = g_strdup(s->getCString());
+    p = s->getCString();
     len = s->getLength();
     while (len > 0) {
       n = font->getNextChar(p, len, &code,
@@ -2681,7 +2690,7 @@ void PdfParser::doShowText(const GooString *s) {
 
   } else {
     state->textTransformDelta(0, state->getRise(), &riseX, &riseY);
-    p = g_strdup(s->getCString());
+    p = s->getCString();
     len = s->getLength();
     while (len > 0) {
       n = font->getNextChar(p, len, &code,
@@ -2727,7 +2736,11 @@ void PdfParser::opXObject(Object args[], int /*numArgs*/)
 {
   Object obj1, obj2, obj3, refObj;
 
-  char *name = g_strdup(args[0].getName());
+#if POPPLER_CHECK_VERSION(0,64,0)
+  const char *name = args[0].getName();
+#else
+  char *name = args[0].getName();
+#endif
 #if defined(POPPLER_NEW_OBJECT_API)
   if ((obj1 = res->lookupXObject(name)).isNull()) {
 #else
diff --git a/src/extension/internal/pdfinput/pdf-parser.h b/src/extension/internal/pdfinput/pdf-parser.h
index 755e6741b0..b27a29cfbf 100644
--- a/src/extension/internal/pdfinput/pdf-parser.h
+++ b/src/extension/internal/pdfinput/pdf-parser.h
@@ -25,6 +25,7 @@ namespace Inkscape {
 // TODO clean up and remove using:
 using Inkscape::Extension::Internal::SvgBuilder;
 
+#include "glib/poppler-features.h"
 #include "goo/gtypes.h"
 #include "Object.h"
 
@@ -287,7 +288,12 @@ private:
   void opMoveShowText(Object args[], int numArgs);
   void opMoveSetShowText(Object args[], int numArgs);
   void opShowSpaceText(Object args[], int numArgs);
+#if POPPLER_CHECK_VERSION(0,64,0)
   void doShowText(const GooString *s);
+#else
+  void doShowText(GooString *s);
+#endif
+  
 
   // XObject operators
   void opXObject(Object args[], int numArgs);
diff --git a/src/extension/internal/pdfinput/svg-builder.cpp b/src/extension/internal/pdfinput/svg-builder.cpp
index 50a7685b89..9d0df7c04d 100644
--- a/src/extension/internal/pdfinput/svg-builder.cpp
+++ b/src/extension/internal/pdfinput/svg-builder.cpp
@@ -1020,9 +1020,9 @@ void SvgBuilder::updateFont(GfxState *state) {
     GfxFont *font = state->getFont();
     // Store original name
     if (font->getName()) {
-        _font_specification = g_strdup(font->getName()->getCString());
+        _font_specification = font->getName()->getCString();
     } else {
-        _font_specification = (char*) "Arial";
+        _font_specification = "Arial";
     }
 
     // Prune the font name to get the correct font family name
@@ -1030,7 +1030,7 @@ void SvgBuilder::updateFont(GfxState *state) {
     char *font_family = NULL;
     char *font_style = NULL;
     char *font_style_lowercase = NULL;
-    char *plus_sign = strstr(_font_specification, "+");
+    const char *plus_sign = strstr(_font_specification, "+");
     if (plus_sign) {
         font_family = g_strdup(plus_sign + 1);
         _font_specification = plus_sign + 1;
diff --git a/src/extension/internal/pdfinput/svg-builder.h b/src/extension/internal/pdfinput/svg-builder.h
index 499724a4cd..729cdc944c 100644
--- a/src/extension/internal/pdfinput/svg-builder.h
+++ b/src/extension/internal/pdfinput/svg-builder.h
@@ -80,7 +80,7 @@ struct SvgGlyph {
     bool style_changed;  // Set to true if style has to be reset
     SPCSSAttr *style;
     int render_mode;    // Text render mode
-    char *font_specification;   // Pointer to current font specification
+    const char *font_specification;   // Pointer to current font specification
 };
 
 /**
@@ -202,7 +202,7 @@ private:
 
     SPCSSAttr *_font_style;          // Current font style
     GfxFont *_current_font;
-    char *_font_specification;
+    const char *_font_specification;
     double _font_scaling;
     bool _need_font_update;
     Geom::Affine _text_matrix;
-- 
2.18.1

From 402c0274420fe39fd2f3393bc7d8d8879d436358 Mon Sep 17 00:00:00 2001
From: Thomas Holder <thomas@thomas-holder.de>
Date: Fri, 28 Sep 2018 18:05:30 +0000
Subject: [PATCH] fix 1789208 poppler 0.69

---
 CMakeScripts/DefineDependsandFlags.cmake      | 12 -----
 src/extension/internal/pdfinput/pdf-input.cpp |  2 +-
 src/extension/internal/pdfinput/pdf-input.h   |  1 +
 .../internal/pdfinput/pdf-parser.cpp          | 46 ++++++++-----------
 src/extension/internal/pdfinput/pdf-parser.h  | 12 +++--
 .../pdfinput/poppler-transition-api.h         | 39 ++++++++++++++++
 .../internal/pdfinput/svg-builder.cpp         | 22 ++++-----
 src/extension/internal/pdfinput/svg-builder.h |  3 +-
 8 files changed, 80 insertions(+), 57 deletions(-)
 create mode 100644 src/extension/internal/pdfinput/poppler-transition-api.h

diff --git a/CMakeScripts/DefineDependsandFlags.cmake b/CMakeScripts/DefineDependsandFlags.cmake
index 40ca7aa65c..9457d58df0 100644
--- a/CMakeScripts/DefineDependsandFlags.cmake
+++ b/CMakeScripts/DefineDependsandFlags.cmake
@@ -126,18 +126,6 @@ if(ENABLE_POPPLER)
 		set(HAVE_POPPLER_GLIB ON)
 	    endif()
 	endif()
-	if(POPPLER_VERSION VERSION_GREATER "0.26.0" OR
-		POPPLER_VERSION VERSION_EQUAL   "0.26.0")
-	    set(POPPLER_EVEN_NEWER_COLOR_SPACE_API ON)
-	endif()
-	if(POPPLER_VERSION VERSION_GREATER "0.29.0" OR
-		POPPLER_VERSION VERSION_EQUAL   "0.29.0")
-	    set(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API ON)
-	endif()
-	if(POPPLER_VERSION VERSION_GREATER "0.58.0" OR
-		POPPLER_VERSION VERSION_EQUAL   "0.58.0")
-            set(POPPLER_NEW_OBJECT_API ON)
-	endif()
     else()
 	set(ENABLE_POPPLER_CAIRO OFF)
     endif()
diff --git a/src/extension/internal/pdfinput/pdf-input.cpp b/src/extension/internal/pdfinput/pdf-input.cpp
index fa9942230b..21a91fa34f 100644
--- a/src/extension/internal/pdfinput/pdf-input.cpp
+++ b/src/extension/internal/pdfinput/pdf-input.cpp
@@ -804,7 +804,7 @@ PdfInput::open(::Inkscape::Extension::Input * /*mod*/, const gchar * uri) {
             dlg->getImportSettings(prefs);
 
         // Apply crop settings
-        PDFRectangle *clipToBox = NULL;
+        _POPPLER_CONST PDFRectangle *clipToBox = NULL;
         double crop_setting;
         sp_repr_get_double(prefs, "cropTo", &crop_setting);
 
diff --git a/src/extension/internal/pdfinput/pdf-input.h b/src/extension/internal/pdfinput/pdf-input.h
index ddcb8f222b..88a894f1c0 100644
--- a/src/extension/internal/pdfinput/pdf-input.h
+++ b/src/extension/internal/pdfinput/pdf-input.h
@@ -15,6 +15,7 @@
 #endif
 
 #ifdef HAVE_POPPLER
+#include "poppler-transition-api.h"
 
 #include <gtkmm/dialog.h>
 
diff --git a/src/extension/internal/pdfinput/pdf-parser.cpp b/src/extension/internal/pdfinput/pdf-parser.cpp
index a3a8ff25a6..96313e1f19 100644
--- a/src/extension/internal/pdfinput/pdf-parser.cpp
+++ b/src/extension/internal/pdfinput/pdf-parser.cpp
@@ -291,8 +291,8 @@ PdfParser::PdfParser(XRef *xrefA,
                      int /*pageNum*/,
 		     int rotate,
 		     Dict *resDict,
-                     PDFRectangle *box,
-		     PDFRectangle *cropBox) :
+                     _POPPLER_CONST PDFRectangle *box,
+                     _POPPLER_CONST PDFRectangle *cropBox) :
     xref(xrefA),
     builder(builderA),
     subPage(gFalse),
@@ -314,7 +314,7 @@ PdfParser::PdfParser(XRef *xrefA,
   builder->setDocumentSize(Inkscape::Util::Quantity::convert(state->getPageWidth(), "pt", "px"),
                            Inkscape::Util::Quantity::convert(state->getPageHeight(), "pt", "px"));
 
-  double *ctm = state->getCTM();
+  const double *ctm = state->getCTM();
   double scaledCTM[6];
   for (int i = 0; i < 6; ++i) {
     baseMatrix[i] = ctm[i];
@@ -349,7 +349,7 @@ PdfParser::PdfParser(XRef *xrefA,
 PdfParser::PdfParser(XRef *xrefA,
 		     Inkscape::Extension::Internal::SvgBuilder *builderA,
                      Dict *resDict,
-		     PDFRectangle *box) :
+		     _POPPLER_CONST PDFRectangle *box) :
     xref(xrefA),
     builder(builderA),
     subPage(gTrue),
@@ -568,7 +568,7 @@ const char *PdfParser::getPreviousOperator(unsigned int look_back) {
 
 void PdfParser::execOp(Object *cmd, Object args[], int numArgs) {
   PdfOperator *op;
-  char *name;
+  const char *name;
   Object *argPtr;
   int i;
 
@@ -616,7 +616,7 @@ void PdfParser::execOp(Object *cmd, Object args[], int numArgs) {
   (this->*op->func)(argPtr, numArgs);
 }
 
-PdfOperator* PdfParser::findOp(char *name) {
+PdfOperator* PdfParser::findOp(const char *name) {
   int a = -1;
   int b = numOps;
   int cmp = -1;
@@ -1748,7 +1748,7 @@ void PdfParser::doShadingPatternFillFallback(GfxShadingPattern *sPat,
                                              GBool stroke, GBool eoFill) {
   GfxShading *shading;
   GfxPath *savedPath;
-  double *ctm, *btm, *ptm;
+  const double *ctm, *btm, *ptm;
   double m[6], ictm[6], m1[6];
   double xMin, yMin, xMax, yMax;
   double det;
@@ -1990,7 +1990,7 @@ void PdfParser::doFunctionShFill1(GfxFunctionShading *shading,
   GfxColor color0M, color1M, colorM0, colorM1, colorMM;
   GfxColor colors2[4];
   double functionColorDelta = colorDeltas[pdfFunctionShading-1];
-  double *matrix;
+  const double *matrix;
   double xM, yM;
   int nComps, i, j;
 
@@ -2170,7 +2170,7 @@ void PdfParser::doPatchMeshShFill(GfxPatchMeshShading *shading) {
   }
 }
 
-void PdfParser::fillPatch(GfxPatch *patch, int nComps, int depth) {
+void PdfParser::fillPatch(_POPPLER_CONST GfxPatch *patch, int nComps, int depth) {
   GfxPatch patch00 = blankPatch();
   GfxPatch patch01 = blankPatch();
   GfxPatch patch10 = blankPatch();
@@ -2591,7 +2591,7 @@ void PdfParser::doShowText(GooString *s) {
   double x, y, dx, dy, tdx, tdy;
   double originX, originY, tOriginX, tOriginY;
   double oldCTM[6], newCTM[6];
-  double *mat;
+  const double *mat;
   Object charProc;
   Dict *resDict;
   Parser *oldParser;
@@ -3665,7 +3665,6 @@ void PdfParser::opBeginImage(Object /*args*/[], int /*numArgs*/)
 Stream *PdfParser::buildImageStream() {
   Object dict;
   Object obj;
-  char *key;
   Stream *str;
 
   // build dictionary
@@ -3683,26 +3682,17 @@ Stream *PdfParser::buildImageStream() {
       obj.free();
 #endif
     } else {
-      key = copyString(obj.getName());
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj = parser->getObj();
-#else
-      obj.free();
-      parser->getObj(&obj);
-#endif
-      if (obj.isEOF() || obj.isError()) {
-	gfree(key);
+      Object obj2;
+      _POPPLER_CALL(obj2, parser->getObj);
+      if (obj2.isEOF() || obj2.isError()) {
+        _POPPLER_FREE(obj);
 	break;
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      dict.dictAdd(key, std::move(obj));
+      _POPPLER_DICTADD(dict, obj.getName(), obj2);
+      _POPPLER_FREE(obj);
+      _POPPLER_FREE(obj2);
     }
-    obj = parser->getObj();
-#else
-      dict.dictAdd(key, &obj);
-    }
-    parser->getObj(&obj);
-#endif
+    _POPPLER_CALL(obj, parser->getObj);
   }
   if (obj.isEOF()) {
     error(errSyntaxError, getPos(), "End of file in inline image");
diff --git a/src/extension/internal/pdfinput/pdf-parser.h b/src/extension/internal/pdfinput/pdf-parser.h
index b27a29cfbf..17eb025468 100644
--- a/src/extension/internal/pdfinput/pdf-parser.h
+++ b/src/extension/internal/pdfinput/pdf-parser.h
@@ -9,6 +9,7 @@
 #define PDF_PARSER_H
 
 #ifdef HAVE_POPPLER
+#include "poppler-transition-api.h"
 
 #ifdef USE_GCC_PRAGMAS
 #pragma interface
@@ -128,11 +129,14 @@ public:
 
   // Constructor for regular output.
   PdfParser(XRef *xrefA, SvgBuilder *builderA, int pageNum, int rotate,
-            Dict *resDict, PDFRectangle *box, PDFRectangle *cropBox);
+            Dict *resDict,
+            _POPPLER_CONST PDFRectangle *box,
+            _POPPLER_CONST PDFRectangle *cropBox);
 
   // Constructor for a sub-page object.
   PdfParser(XRef *xrefA, Inkscape::Extension::Internal::SvgBuilder *builderA,
-            Dict *resDict, PDFRectangle *box);
+            Dict *resDict,
+            _POPPLER_CONST PDFRectangle *box);
 
   virtual ~PdfParser();
 
@@ -186,7 +190,7 @@ private:
 
   void go(GBool topLevel);
   void execOp(Object *cmd, Object args[], int numArgs);
-  PdfOperator *findOp(char *name);
+  PdfOperator *findOp(const char *name);
   GBool checkArg(Object *arg, TchkType type);
   int getPos();
 
@@ -257,7 +261,7 @@ private:
 			   double x2, double y2, GfxColor *color2,
 			   int nComps, int depth);
   void doPatchMeshShFill(GfxPatchMeshShading *shading);
-  void fillPatch(GfxPatch *patch, int nComps, int depth);
+  void fillPatch(_POPPLER_CONST GfxPatch *patch, int nComps, int depth);
   void doEndPath();
 
   // path clipping operators
diff --git a/src/extension/internal/pdfinput/poppler-transition-api.h b/src/extension/internal/pdfinput/poppler-transition-api.h
new file mode 100644
index 0000000000..898e64bf2b
--- /dev/null
+++ b/src/extension/internal/pdfinput/poppler-transition-api.h
@@ -0,0 +1,39 @@
+#ifndef SEEN_POPPLER_TRANSITION_API_H
+#define SEEN_POPPLER_TRANSITION_API_H
+
+#include <glib/poppler-features.h>
+
+#if POPPLER_CHECK_VERSION(0,70,0)
+#define _POPPLER_CONST const
+#else
+#define _POPPLER_CONST
+#endif
+
+#if POPPLER_CHECK_VERSION(0,69,0)
+#define _POPPLER_DICTADD(dict, key, obj) (dict).dictAdd(key, std::move(obj))
+#elif POPPLER_CHECK_VERSION(0,58,0)
+#define _POPPLER_DICTADD(dict, key, obj) (dict).dictAdd(copyString(key), std::move(obj))
+#else
+#define _POPPLER_DICTADD(dict, key, obj) (dict).dictAdd(copyString(key), &obj)
+#endif
+
+#if POPPLER_CHECK_VERSION(0,58,0)
+#define POPPLER_NEW_OBJECT_API
+#define _POPPLER_FREE(obj)
+#define _POPPLER_CALL(ret, func) (ret = func())
+#define _POPPLER_CALL_ARGS(ret, func, ...) (ret = func(__VA_ARGS__))
+#else
+#define _POPPLER_FREE(obj) (obj).free()
+#define _POPPLER_CALL(ret, func) (*func(&ret))
+#define _POPPLER_CALL_ARGS(ret, func, ...) (*func(__VA_ARGS__, &ret))
+#endif
+
+#if POPPLER_CHECK_VERSION(0, 29, 0)
+#define POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API
+#endif
+
+#if POPPLER_CHECK_VERSION(0, 25, 0)
+#define POPPLER_EVEN_NEWER_COLOR_SPACE_API
+#endif
+
+#endif
diff --git a/src/extension/internal/pdfinput/svg-builder.cpp b/src/extension/internal/pdfinput/svg-builder.cpp
index 9d0df7c04d..a59397a100 100644
--- a/src/extension/internal/pdfinput/svg-builder.cpp
+++ b/src/extension/internal/pdfinput/svg-builder.cpp
@@ -625,7 +625,7 @@ gchar *SvgBuilder::_createPattern(GfxPattern *pattern, GfxState *state, bool is_
     if ( pattern != nullptr ) {
         if ( pattern->getType() == 2 ) {  // Shading pattern
             GfxShadingPattern *shading_pattern = static_cast<GfxShadingPattern *>(pattern);
-            double *ptm;
+            const double *ptm;
             double m[6] = {1, 0, 0, 1, 0, 0};
             double det;
 
@@ -672,7 +672,7 @@ gchar *SvgBuilder::_createTilingPattern(GfxTilingPattern *tiling_pattern,
 
     Inkscape::XML::Node *pattern_node = _xml_doc->createElement("svg:pattern");
     // Set pattern transform matrix
-    double *p2u = tiling_pattern->getMatrix();
+    const double *p2u = tiling_pattern->getMatrix();
     double m[6] = {1, 0, 0, 1, 0, 0};
     double det;
     det = _ttm[0] * _ttm[3] - _ttm[1] * _ttm[2];    // see LP Bug 1168908
@@ -698,7 +698,7 @@ gchar *SvgBuilder::_createTilingPattern(GfxTilingPattern *tiling_pattern,
     pattern_node->setAttribute("patternUnits", "userSpaceOnUse");
     // Set pattern tiling
     // FIXME: don't ignore XStep and YStep
-    double *bbox = tiling_pattern->getBBox();
+    const double *bbox = tiling_pattern->getBBox();
     sp_repr_set_svg_double(pattern_node, "x", 0.0);
     sp_repr_set_svg_double(pattern_node, "y", 0.0);
     sp_repr_set_svg_double(pattern_node, "width", bbox[2] - bbox[0]);
@@ -751,7 +751,7 @@ gchar *SvgBuilder::_createTilingPattern(GfxTilingPattern *tiling_pattern,
  */
 gchar *SvgBuilder::_createGradient(GfxShading *shading, double *matrix, bool for_shading) {
     Inkscape::XML::Node *gradient;
-    Function *func;
+    _POPPLER_CONST Function *func;
     int num_funcs;
     bool extend0, extend1;
 
@@ -865,7 +865,7 @@ static bool svgGetShadingColorRGB(GfxShading *shading, double offset, GfxRGB *re
 
 #define INT_EPSILON 8
 bool SvgBuilder::_addGradientStops(Inkscape::XML::Node *gradient, GfxShading *shading,
-                                   Function *func) {
+                                   _POPPLER_CONST Function *func) {
     int type = func->getType();
     if ( type == 0 || type == 2 ) {  // Sampled or exponential function
         GfxRGB stop1, stop2;
@@ -877,9 +877,9 @@ bool SvgBuilder::_addGradientStops(Inkscape::XML::Node *gradient, GfxShading *sh
             _addStopToGradient(gradient, 1.0, &stop2, 1.0);
         }
     } else if ( type == 3 ) { // Stitching
-        StitchingFunction *stitchingFunc = static_cast<StitchingFunction*>(func);
-        double *bounds = stitchingFunc->getBounds();
-        double *encode = stitchingFunc->getEncode();
+        auto stitchingFunc = static_cast<_POPPLER_CONST StitchingFunction*>(func);
+        const double *bounds = stitchingFunc->getBounds();
+        const double *encode = stitchingFunc->getEncode();
         int num_funcs = stitchingFunc->getNumFuncs();
 
         // Add stops from all the stitched functions
@@ -890,7 +890,7 @@ bool SvgBuilder::_addGradientStops(Inkscape::XML::Node *gradient, GfxShading *sh
             svgGetShadingColorRGB(shading, bounds[i + 1], &color);
             // Add stops
             if (stitchingFunc->getFunc(i)->getType() == 2) {    // process exponential fxn
-                double expE = (static_cast<ExponentialFunction*>(stitchingFunc->getFunc(i)))->getE();
+                double expE = (static_cast<_POPPLER_CONST ExponentialFunction*>(stitchingFunc->getFunc(i)))->getE();
                 if (expE > 1.0) {
                     expE = (bounds[i + 1] - bounds[i])/expE;    // approximate exponential as a single straight line at x=1
                     if (encode[2*i] == 0) {    // normal sequence
@@ -1148,7 +1148,7 @@ void SvgBuilder::updateFont(GfxState *state) {
     Inkscape::CSSOStringStream os_font_size;
     double css_font_size = _font_scaling * state->getFontSize();
     if ( font->getType() == fontType3 ) {
-        double *font_matrix = font->getFontMatrix();
+        const double *font_matrix = font->getFontMatrix();
         if ( font_matrix[0] != 0.0 ) {
             css_font_size *= font_matrix[3] / font_matrix[0];
         }
@@ -1193,7 +1193,7 @@ void SvgBuilder::updateTextPosition(double tx, double ty) {
 void SvgBuilder::updateTextMatrix(GfxState *state) {
     _flushText();
     // Update text matrix
-    double *text_matrix = state->getTextMat();
+    const double *text_matrix = state->getTextMat();
     double w_scale = sqrt( text_matrix[0] * text_matrix[0] + text_matrix[2] * text_matrix[2] );
     double h_scale = sqrt( text_matrix[1] * text_matrix[1] + text_matrix[3] * text_matrix[3] );
     double max_scale;
diff --git a/src/extension/internal/pdfinput/svg-builder.h b/src/extension/internal/pdfinput/svg-builder.h
index 729cdc944c..7fdb0b5fcd 100644
--- a/src/extension/internal/pdfinput/svg-builder.h
+++ b/src/extension/internal/pdfinput/svg-builder.h
@@ -15,6 +15,7 @@
 #endif
 
 #ifdef HAVE_POPPLER
+#include "poppler-transition-api.h"
 
 class SPDocument;
 namespace Inkscape {
@@ -174,7 +175,7 @@ private:
     void _addStopToGradient(Inkscape::XML::Node *gradient, double offset,
                             GfxRGB *color, double opacity);
     bool _addGradientStops(Inkscape::XML::Node *gradient, GfxShading *shading,
-                           Function *func);
+                           _POPPLER_CONST Function *func);
     gchar *_createTilingPattern(GfxTilingPattern *tiling_pattern, GfxState *state,
                                 bool is_stroke=false);
     // Image/mask creation
-- 
2.18.1

From 0ab3449247d9356f57c75893e1ecfa195d43b681 Mon Sep 17 00:00:00 2001
From: Thomas Holder <thomas@thomas-holder.de>
Date: Sun, 30 Sep 2018 19:05:48 +0200
Subject: [PATCH] use poppler-transition-api instead of ifdefs

---
 .../internal/pdfinput/pdf-parser.cpp          | 906 ++++--------------
 .../pdfinput/poppler-transition-api.h         |   4 +-
 2 files changed, 208 insertions(+), 702 deletions(-)

diff --git a/src/extension/internal/pdfinput/pdf-parser.cpp b/src/extension/internal/pdfinput/pdf-parser.cpp
index 96313e1f19..9e4cd583fa 100644
--- a/src/extension/internal/pdfinput/pdf-parser.cpp
+++ b/src/extension/internal/pdfinput/pdf-parser.cpp
@@ -410,21 +410,13 @@ void PdfParser::parse(Object *obj, GBool topLevel) {
 
   if (obj->isArray()) {
     for (int i = 0; i < obj->arrayGetLength(); ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj2 = obj->arrayGet(i);
-#else
-      obj->arrayGet(i, &obj2);
-#endif
+      _POPPLER_CALL_ARGS(obj2, obj->arrayGet, i);
       if (!obj2.isStream()) {
 	error(errInternal, -1, "Weird page contents");
-#if !defined(POPPLER_NEW_OBJECT_API)
-	obj2.free();
-#endif
+	_POPPLER_FREE(obj2);
 	return;
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj2.free();
-#endif
+      _POPPLER_FREE(obj2);
     }
   } else if (!obj->isStream()) {
 	error(errInternal, -1, "Weird page contents");
@@ -443,11 +435,7 @@ void PdfParser::go(GBool /*topLevel*/)
 
   // scan a sequence of objects
   int numArgs = 0;
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj = parser->getObj();
-#else
-  parser->getObj(&obj);
-#endif
+  _POPPLER_CALL(obj, parser->getObj);
   while (!obj.isEOF()) {
 
     // got a command - execute it
@@ -466,19 +454,15 @@ void PdfParser::go(GBool /*topLevel*/)
       execOp(&obj, args, numArgs);
 
 #if !defined(POPPLER_NEW_OBJECT_API)
-      obj.free();
+      _POPPLER_FREE(obj);
       for (int i = 0; i < numArgs; ++i)
-	args[i].free();
+	_POPPLER_FREE(args[i]);
 #endif
       numArgs = 0;
 
     // got an argument - save it
     } else if (numArgs < maxArgs) {
-#if defined(POPPLER_NEW_OBJECT_API)
       args[numArgs++] = std::move(obj);
-#else
-      args[numArgs++] = obj;
-#endif
 
     // too many arguments - something is wrong
     } else {
@@ -489,21 +473,13 @@ void PdfParser::go(GBool /*topLevel*/)
 	printf("\n");
 	fflush(stdout);
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj.free();
-#endif
+      _POPPLER_FREE(obj);
     }
 
     // grab the next object
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj = parser->getObj();
-#else
-    parser->getObj(&obj);
-#endif
+    _POPPLER_CALL(obj, parser->getObj);
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
 
   // args at end with no command
   if (numArgs > 0) {
@@ -519,7 +495,7 @@ void PdfParser::go(GBool /*topLevel*/)
     }
 #if !defined(POPPLER_NEW_OBJECT_API)
     for (int i = 0; i < numArgs; ++i)
-      args[i].free();
+      _POPPLER_FREE(args[i]);
 #endif
   }
 }
@@ -716,13 +692,9 @@ void PdfParser::opSetDash(Object args[], int /*numArgs*/)
   if (length != 0) {
     dash = (double *)gmallocn(length, sizeof(double));
     for (int i = 0; i < length; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      dash[i] = a->get(i).getNum();
-#else
       Object obj;
-      dash[i] = a->get(i, &obj)->getNum();
-      obj.free();
-#endif
+      dash[i] = _POPPLER_CALL_ARGS_DEREF(obj, a->get, i).getNum();
+      _POPPLER_FREE(obj);
     }
   }
   state->setLineDash(dash, length, args[1].getNum());
@@ -772,18 +744,13 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
   GBool haveBackdropColor = gFalse;
   GBool alpha = gFalse;
 
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj1 = res->lookupGState(args[0].getName())).isNull()) {
-#else
-  if (!res->lookupGState(args[0].getName(), &obj1)) {
-#endif
+  _POPPLER_CALL_ARGS(obj1, res->lookupGState, args[0].getName());
+  if (obj1.isNull()) {
     return;
   }
   if (!obj1.isDict()) {
     error(errSyntaxError, getPos(), "ExtGState '{0:s}' is wrong type"), args[0].getName();
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     return;
   }
   if (printCommands) {
@@ -793,11 +760,7 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
   }
 
   // transparency support: blend mode, fill/stroke opacity
-#if defined(POPPLER_NEW_OBJECT_API)
-  if (!((obj2 = obj1.dictLookup(const_cast<char*>("BM"))).isNull())) {
-#else
-  if (!obj1.dictLookup(const_cast<char*>("BM"), &obj2)->isNull()) {
-#endif
+  if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "BM").isNull()) {
     GfxBlendMode mode = gfxBlendNormal;
     if (state->parseBlendMode(&obj2, &mode)) {
       state->setBlendMode(mode);
@@ -805,71 +768,40 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
       error(errSyntaxError, getPos(), "Invalid blend mode in ExtGState");
     }
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("ca"))).isNum()) {
-#else
-  obj2.free();
-  if (obj1.dictLookup(const_cast<char*>("ca"), &obj2)->isNum()) {
-#endif
+  _POPPLER_FREE(obj2);
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "ca").isNum()) {
     state->setFillOpacity(obj2.getNum());
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("CA"))).isNum()) {
-#else
-  obj2.free();
-  if (obj1.dictLookup(const_cast<char*>("CA"), &obj2)->isNum()) {
-#endif
+  _POPPLER_FREE(obj2);
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "CA").isNum()) {
     state->setStrokeOpacity(obj2.getNum());
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // fill/stroke overprint
   GBool haveFillOP = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((haveFillOP = (obj2 = obj1.dictLookup(const_cast<char*>("op"))).isBool())) {
-#else
-  if ((haveFillOP = (obj1.dictLookup(const_cast<char*>("op"), &obj2)->isBool()))) {
-#endif
+  if ((haveFillOP = _POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "op").isBool())) {
     state->setFillOverprint(obj2.getBool());
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("OP"))).isBool()) {
-#else
-  obj2.free();
-  if (obj1.dictLookup(const_cast<char*>("OP"), &obj2)->isBool()) {
-#endif
+  _POPPLER_FREE(obj2);
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "OP").isBool()) {
     state->setStrokeOverprint(obj2.getBool());
     if (!haveFillOP) {
       state->setFillOverprint(obj2.getBool());
     }
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // stroke adjust
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("SA"))).isBool()) {
-#else
-  if (obj1.dictLookup(const_cast<char*>("SA"), &obj2)->isBool()) {
-#endif
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SA").isBool()) {
     state->setStrokeAdjust(obj2.getBool());
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // transfer function
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("TR2"))).isNull()) {
-    obj2 = obj1.dictLookup(const_cast<char*>("TR"));
-#else
-  if (obj1.dictLookup(const_cast<char*>("TR2"), &obj2)->isNull()) {
-    obj2.free();
-    obj1.dictLookup(const_cast<char*>("TR"), &obj2);
-#endif
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "TR2").isNull()) {
+    _POPPLER_FREE(obj2);
+    _POPPLER_CALL_ARGS(obj2, obj1.dictLookup, "TR");
   }
   if (obj2.isName(const_cast<char*>("Default")) ||
       obj2.isName(const_cast<char*>("Identity"))) {
@@ -878,15 +810,9 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
   } else if (obj2.isArray() && obj2.arrayGetLength() == 4) {
     int pos = 4;
     for (int i = 0; i < 4; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj3 = obj2.arrayGet(i);
-#else
-      obj2.arrayGet(i, &obj3);
-#endif
+      _POPPLER_CALL_ARGS(obj3, obj2.arrayGet, i);
       funcs[i] = Function::parse(&obj3);
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj3.free();
-#endif
+      _POPPLER_FREE(obj3);
       if (!funcs[i]) {
 	pos = i;
 	break;
@@ -903,37 +829,21 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
   } else if (!obj2.isNull()) {
     error(errSyntaxError, getPos(), "Invalid transfer function in ExtGState");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // soft mask
-#if defined(POPPLER_NEW_OBJECT_API)
-  if (!((obj2 = obj1.dictLookup(const_cast<char*>("SMask"))).isNull())) {
-#else
-  if (!obj1.dictLookup(const_cast<char*>("SMask"), &obj2)->isNull()) {
-#endif
+  if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SMask").isNull()) {
     if (obj2.isName(const_cast<char*>("None"))) {
       builder->clearSoftMask(state);
     } else if (obj2.isDict()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj2.dictLookup(const_cast<char*>("S"))).isName(const_cast<char*>("Alpha"))) {
-#else
-      if (obj2.dictLookup(const_cast<char*>("S"), &obj3)->isName(const_cast<char*>("Alpha"))) {
-#endif
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "S").isName("Alpha")) {
 	alpha = gTrue;
       } else { // "Luminosity"
 	alpha = gFalse;
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj3.free();
-#endif
+      _POPPLER_FREE(obj3);
       funcs[0] = NULL;
-#if defined(POPPLER_NEW_OBJECT_API)
-      if (!((obj3 = obj2.dictLookup(const_cast<char*>("TR"))).isNull())) {
-#else
-      if (!obj2.dictLookup(const_cast<char*>("TR"), &obj3)->isNull()) {
-#endif
+      if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "TR").isNull()) {
 	funcs[0] = Function::parse(&obj3);
 	if (funcs[0]->getInputSize() != 1 ||
 	    funcs[0]->getOutputSize() != 1) {
@@ -942,45 +852,26 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
 	  funcs[0] = NULL;
 	}
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((haveBackdropColor = (obj3 = obj2.dictLookup(const_cast<char*>("BC"))).isArray())) {
-#else
-      obj3.free();
-      if ((haveBackdropColor = obj2.dictLookup(const_cast<char*>("BC"), &obj3)->isArray())) {
-#endif
+      _POPPLER_FREE(obj3);
+      if ((haveBackdropColor = _POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "BC").isArray())) {
 	for (int i = 0; i < gfxColorMaxComps; ++i) {
 	  backdropColor.c[i] = 0;
 	}
 	for (int i = 0; i < obj3.arrayGetLength() && i < gfxColorMaxComps; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	  obj4 = obj3.arrayGet(i);
-#else
-	  obj3.arrayGet(i, &obj4);
-#endif
+          _POPPLER_CALL_ARGS(obj4, obj3.arrayGet, i);
 	  if (obj4.isNum()) {
 	    backdropColor.c[i] = dblToCol(obj4.getNum());
 	  }
-#if !defined(POPPLER_NEW_OBJECT_API)
-	  obj4.free();
-#endif
+	  _POPPLER_FREE(obj4);
 	}
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj2.dictLookup(const_cast<char*>("G"))).isStream()) {
-	if ((obj4 = obj3.streamGetDict()->lookup(const_cast<char*>("Group"))).isDict()) {
-#else
-      obj3.free();
-      if (obj2.dictLookup(const_cast<char*>("G"), &obj3)->isStream()) {
-	if (obj3.streamGetDict()->lookup(const_cast<char*>("Group"), &obj4)->isDict()) {
-#endif
+      _POPPLER_FREE(obj3);
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "G").isStream()) {
+	if (_POPPLER_CALL_ARGS_DEREF(obj4, obj3.streamGetDict()->lookup, "Group").isDict()) {
 	  GfxColorSpace *blendingColorSpace = 0;
 	  GBool isolated = gFalse;
 	  GBool knockout = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-	  if (!((obj5 = obj4.dictLookup(const_cast<char*>("CS"))).isNull())) {
-#else
-	  if (!obj4.dictLookup(const_cast<char*>("CS"), &obj5)->isNull()) {
-#endif
+	  if (!_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "CS").isNull()) {
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
 	    blendingColorSpace = GfxColorSpace::parse(NULL, &obj5, NULL, NULL);
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
@@ -989,25 +880,15 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
 	    blendingColorSpace = GfxColorSpace::parse(&obj5, NULL, NULL);
 #endif
 	  }
-#if defined(POPPLER_NEW_OBJECT_API)
-	  if ((obj5 = obj4.dictLookup(const_cast<char*>("I"))).isBool()) {
-#else
-	  obj5.free();
-	  if (obj4.dictLookup(const_cast<char*>("I"), &obj5)->isBool()) {
-#endif
+          _POPPLER_FREE(obj5);
+	  if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "I").isBool()) {
 	    isolated = obj5.getBool();
 	  }
-#if defined(POPPLER_NEW_OBJECT_API)
-	  if ((obj5 = obj4.dictLookup(const_cast<char*>("K"))).isBool()) {
-#else
-	  obj5.free();
-	  if (obj4.dictLookup(const_cast<char*>("K"), &obj5)->isBool()) {
-#endif
+          _POPPLER_FREE(obj5);
+	  if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "K").isBool()) {
 	    knockout = obj5.getBool();
 	  }
-#if !defined(POPPLER_NEW_OBJECT_API)
-	  obj5.free();
-#endif
+	  _POPPLER_FREE(obj5);
 	  if (!haveBackdropColor) {
 	    if (blendingColorSpace) {
 	      blendingColorSpace->getDefaultColor(&backdropColor);
@@ -1026,24 +907,18 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
 	} else {
 	  error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
 	}
-#if !defined(POPPLER_NEW_OBJECT_API)
-	obj4.free();
-#endif
+	_POPPLER_FREE(obj4);
       } else {
 	error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj3.free();
-#endif
+      _POPPLER_FREE(obj3);
     } else if (!obj2.isNull()) {
       error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState");
     }
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
+  _POPPLER_FREE(obj2);
 
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 }
 
 void PdfParser::doSoftMask(Object *str, GBool alpha,
@@ -1064,79 +939,43 @@ void PdfParser::doSoftMask(Object *str, GBool alpha,
   dict = str->streamGetDict();
 
   // check form type
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("FormType"));
-#else
-  dict->lookup(const_cast<char*>("FormType"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "FormType");
   if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {
     error(errSyntaxError, getPos(), "Unknown form type");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get bounding box
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("BBox"));
-#else
-  dict->lookup(const_cast<char*>("BBox"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "BBox");
   if (!obj1.isArray()) {
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     error(errSyntaxError, getPos(), "Bad form bounding box");
     return;
   }
   for (i = 0; i < 4; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj2 = obj1.arrayGet(i);
-#else
-    obj1.arrayGet(i, &obj2);
-#endif
+    _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, i);
     bbox[i] = obj2.getNum();
-#if defined(POPPLER_NEW_OBJECT_API)
-  }
-#else
-    obj2.free();
+    _POPPLER_FREE(obj2);
   }
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get matrix
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("Matrix"));
-#else
-  dict->lookup(const_cast<char*>("Matrix"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "Matrix");
   if (obj1.isArray()) {
     for (i = 0; i < 6; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj2 = obj1.arrayGet(i);
-#else
-      obj1.arrayGet(i, &obj2);
-#endif
+      _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, i);
       m[i] = obj2.getNum();
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj2.free();
-#endif
+      _POPPLER_FREE(obj2);
     }
   } else {
     m[0] = 1; m[1] = 0;
     m[2] = 0; m[3] = 1;
     m[4] = 0; m[5] = 0;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get resources
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("Resources"));
-#else
-  dict->lookup(const_cast<char*>("Resources"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "Resources");
   resDict = obj1.isDict() ? obj1.getDict() : (Dict *)NULL;
 
   // draw it
@@ -1149,9 +988,7 @@ void PdfParser::doSoftMask(Object *str, GBool alpha,
   if (blendingColorSpace) {
     delete blendingColorSpace;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 }
 
 void PdfParser::opSetRenderingIntent(Object /*args*/[], int /*numArgs*/)
@@ -1248,11 +1085,7 @@ void PdfParser::opSetFillColorSpace(Object args[], int /*numArgs*/)
   Object obj;
 
   state->setFillPattern(NULL);
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj = res->lookupColorSpace(args[0].getName());
-#else
-  res->lookupColorSpace(args[0].getName(), &obj);
-#endif
+  _POPPLER_CALL_ARGS(obj, res->lookupColorSpace, args[0].getName());
 
   GfxColorSpace *colorSpace = NULL;
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
@@ -1274,9 +1107,7 @@ void PdfParser::opSetFillColorSpace(Object args[], int /*numArgs*/)
     colorSpace = GfxColorSpace::parse(&obj, NULL);
   }
 #endif
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
   if (colorSpace) {
   GfxColor color;
     state->setFillColorSpace(colorSpace);
@@ -1295,11 +1126,7 @@ void PdfParser::opSetStrokeColorSpace(Object args[], int /*numArgs*/)
   GfxColorSpace *colorSpace = NULL;
 
   state->setStrokePattern(NULL);
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj = res->lookupColorSpace(args[0].getName());
-#else
-  res->lookupColorSpace(args[0].getName(), &obj);
-#endif
+  _POPPLER_CALL_ARGS(obj, res->lookupColorSpace, args[0].getName());
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
   if (obj.isNull()) {
     colorSpace = GfxColorSpace::parse(NULL, &args[0], NULL, NULL);
@@ -1319,9 +1146,7 @@ void PdfParser::opSetStrokeColorSpace(Object args[], int /*numArgs*/)
     colorSpace = GfxColorSpace::parse(&obj, NULL);
   }
 #endif
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
   if (colorSpace) {
     GfxColor color;
     state->setStrokeColorSpace(colorSpace);
@@ -2551,11 +2376,7 @@ void PdfParser::opShowSpaceText(Object args[], int /*numArgs*/)
   wMode = state->getFont()->getWMode();
   a = args[0].getArray();
   for (int i = 0; i < a->getLength(); ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj = a->get(i);
-#else
-    a->get(i, &obj);
-#endif
+    _POPPLER_CALL_ARGS(obj, a->get, i);
     if (obj.isNum()) {
       // this uses the absolute value of the font size to match
       // Acrobat's behavior
@@ -2572,9 +2393,7 @@ void PdfParser::opShowSpaceText(Object args[], int /*numArgs*/)
     } else {
       error(errSyntaxError, getPos(), "Element of show/space array must be number or string");
     }
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj.free();
-#endif
+    _POPPLER_FREE(obj);
   }
 }
 
@@ -2655,11 +2474,7 @@ void PdfParser::doShowText(GooString *s) {
       //out->updateCTM(state, 1, 0, 0, 1, 0, 0);
       if (false){ /*!out->beginType3Char(state, curX + riseX, curY + riseY, tdx, tdy,
 			       code, u, uLen)) {*/
-#if defined(POPPLER_NEW_OBJECT_API)
-	charProc = ((Gfx8BitFont *)font)->getCharProc(code);
-#else
-	((Gfx8BitFont *)font)->getCharProc(code, &charProc);
-#endif
+        _POPPLER_CALL_ARGS(charProc, ((Gfx8BitFont *)font)->getCharProc, code);
 	if ((resDict = ((Gfx8BitFont *)font)->getResources())) {
 	  pushResources(resDict);
 	}
@@ -2672,9 +2487,7 @@ void PdfParser::doShowText(GooString *s) {
 	if (resDict) {
 	  popResources();
 	}
-#if !defined(POPPLER_NEW_OBJECT_API)
-	charProc.free();
-#endif
+	_POPPLER_FREE(charProc);
       }
       restoreState();
       // GfxState::restore() does *not* restore the current position,
@@ -2741,43 +2554,24 @@ void PdfParser::opXObject(Object args[], int /*numArgs*/)
 #else
   char *name = args[0].getName();
 #endif
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj1 = res->lookupXObject(name)).isNull()) {
-#else
-  if (!res->lookupXObject(name, &obj1)) {
-#endif
+  _POPPLER_CALL_ARGS(obj1, res->lookupXObject, name);
+  if (obj1.isNull()) {
     return;
   }
   if (!obj1.isStream()) {
     error(errSyntaxError, getPos(), "XObject '{0:s}' is wrong type", name);
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     return;
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj2 = obj1.streamGetDict()->lookup(const_cast<char*>("Subtype"));
-#else
-  obj1.streamGetDict()->lookup(const_cast<char*>("Subtype"), &obj2);
-#endif
+  _POPPLER_CALL_ARGS(obj2, obj1.streamGetDict()->lookup, "Subtype");
   if (obj2.isName(const_cast<char*>("Image"))) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    refObj = res->lookupXObjectNF(name);
-#else
-    res->lookupXObjectNF(name, &refObj);
-#endif
+    _POPPLER_CALL_ARGS(refObj, res->lookupXObjectNF, name);
     doImage(&refObj, obj1.getStream(), gFalse);
-#if !defined(POPPLER_NEW_OBJECT_API)
-    refObj.free();
-#endif
+    _POPPLER_FREE(refObj);
   } else if (obj2.isName(const_cast<char*>("Form"))) {
     doForm(&obj1);
   } else if (obj2.isName(const_cast<char*>("PS"))) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj3 = obj1.streamGetDict()->lookup(const_cast<char*>("Level1"));
-#else
-    obj1.streamGetDict()->lookup(const_cast<char*>("Level1"), &obj3);
-#endif
+    _POPPLER_CALL_ARGS(obj3, obj1.streamGetDict()->lookup, "Level1");
 /*    out->psXObject(obj1.getStream(),
     		   obj3.isStream() ? obj3.getStream() : (Stream *)NULL);*/
   } else if (obj2.isName()) {
@@ -2785,10 +2579,8 @@ void PdfParser::opXObject(Object args[], int /*numArgs*/)
   } else {
     error(errSyntaxError, getPos(), "XObject subtype is missing or wrong type");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj2);
+  _POPPLER_FREE(obj1);
 }
 
 void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
@@ -2815,18 +2607,10 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
     dict = str->getDict();
     
     // get size
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup(const_cast<char*>("Width"));
-#else
-    dict->lookup(const_cast<char*>("Width"), &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "Width");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("W"));
-#else
-        obj1.free();
-        dict->lookup(const_cast<char*>("W"), &obj1);
-#endif
+        _POPPLER_FREE(obj1);
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "W");
     }
     if (obj1.isInt()){
         width = obj1.getInt();
@@ -2837,19 +2621,11 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
     else {
         goto err2;
     }
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup(const_cast<char*>("Height"));
-#else
-    obj1.free();
-    dict->lookup(const_cast<char*>("Height"), &obj1);
-#endif
+    _POPPLER_FREE(obj1);
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "Height");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("H"));
-#else
-        obj1.free();
-        dict->lookup(const_cast<char*>("H"), &obj1);
-#endif
+        _POPPLER_FREE(obj1);
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "H");
     }
     if (obj1.isInt()) {
         height = obj1.getInt();
@@ -2860,46 +2636,26 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
     else {
         goto err2;
     }
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     
     // image interpolation
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup("Interpolate");
-#else
-    dict->lookup("Interpolate", &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "Interpolate");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj1 = dict->lookup("I");
-#else
-      obj1.free();
-      dict->lookup("I", &obj1);
-#endif
+      _POPPLER_FREE(obj1);
+      _POPPLER_CALL_ARGS(obj1, dict->lookup, "I");
     }
     if (obj1.isBool())
       interpolate = obj1.getBool();
     else
       interpolate = gFalse;
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     maskInterpolate = gFalse;
 
     // image or mask?
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup(const_cast<char*>("ImageMask"));
-#else
-    dict->lookup(const_cast<char*>("ImageMask"), &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "ImageMask");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("IM"));
-#else
-        obj1.free();
-        dict->lookup(const_cast<char*>("IM"), &obj1);
-#endif
+        _POPPLER_FREE(obj1);
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "IM");
     }
     mask = gFalse;
     if (obj1.isBool()) {
@@ -2908,24 +2664,14 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
     else if (!obj1.isNull()) {
         goto err2;
     }
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     
     // bit depth
     if (bits == 0) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("BitsPerComponent"));
-#else
-        dict->lookup(const_cast<char*>("BitsPerComponent"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "BitsPerComponent");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("BPC"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("BPC"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "BPC");
         }
         if (obj1.isInt()) {
             bits = obj1.getInt();
@@ -2934,9 +2680,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         } else {
             goto err2;
         }
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
     }
     
     // display a mask
@@ -2946,37 +2690,21 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
             goto err1;
         }
         invert = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("Decode"));
-#else
-        dict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "Decode");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("D"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "D");
         }
         if (obj1.isArray()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj2 = obj1.arrayGet(0);
-#else
-            obj1.arrayGet(0, &obj2);
-#endif
+            _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, 0);
             if (obj2.isInt() && obj2.getInt() == 1) {
                 invert = gTrue;
             }
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj2.free();
-#endif
+            _POPPLER_FREE(obj2);
         } else if (!obj1.isNull()) {
             goto err2;
         }
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
         
         // draw it
         builder->addImageMask(state, str, width, height, invert, interpolate);
@@ -2984,36 +2712,18 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
     } else {
         // get color space and color map
         GfxColorSpace *colorSpace;
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("ColorSpace"));
-#else
-        dict->lookup(const_cast<char*>("ColorSpace"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "ColorSpace");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("CS"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("CS"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "CS");
         }
         if (obj1.isName()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj2 = res->lookupColorSpace(obj1.getName());
-#else
-            res->lookupColorSpace(obj1.getName(), &obj2);
-#endif
+            _POPPLER_CALL_ARGS(obj2, res->lookupColorSpace, obj1.getName());
             if (!obj2.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
+	            _POPPLER_FREE(obj1);
                     obj1 = std::move(obj2);
-#else
-	            obj1.free();
-	            obj1 = obj2;
-#endif
             } else {
-#if !defined(POPPLER_NEW_OBJECT_API)
-	            obj2.free();
-#endif
+	            _POPPLER_FREE(obj2);
             }
         }
         if (!obj1.isNull()) {
@@ -3033,29 +2743,17 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         } else {
             colorSpace = NULL;
         }
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
         if (!colorSpace) {
             goto err1;
         }
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("Decode"));
-#else
-        dict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "Decode");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("D"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "D");
         }
         GfxImageColorMap *colorMap = new GfxImageColorMap(bits, &obj1, colorSpace);
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
         if (!colorMap->isOk()) {
             delete colorMap;
             goto err1;
@@ -3069,13 +2767,8 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         int maskHeight = 0;
         maskInvert = gFalse;
         GfxImageColorMap *maskColorMap = NULL;
-#if defined(POPPLER_NEW_OBJECT_API)
-        maskObj = dict->lookup(const_cast<char*>("Mask"));
-        smaskObj = dict->lookup(const_cast<char*>("SMask"));
-#else
-        dict->lookup(const_cast<char*>("Mask"), &maskObj);
-        dict->lookup(const_cast<char*>("SMask"), &smaskObj);
-#endif
+        _POPPLER_CALL_ARGS(maskObj, dict->lookup, "Mask");
+        _POPPLER_CALL_ARGS(smaskObj, dict->lookup, "SMask");
         Dict* maskDict;
         if (smaskObj.isStream()) {
             // soft mask
@@ -3084,108 +2777,58 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
             }
             maskStr = smaskObj.getStream();
             maskDict = smaskObj.streamGetDict();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Width"));
-#else
-            maskDict->lookup(const_cast<char*>("Width"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Width");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	            obj1 = maskDict->lookup(const_cast<char*>("W"));
-#else
-        	    obj1.free();
-	            maskDict->lookup(const_cast<char*>("W"), &obj1);
-#endif
+                    _POPPLER_FREE(obj1);
+	            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "W");
             }
             if (!obj1.isInt()) {
 	            goto err2;
             }
             maskWidth = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Height"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("Height"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Height");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                    obj1 = maskDict->lookup(const_cast<char*>("H"));
-#else
-	            obj1.free();
-	            maskDict->lookup(const_cast<char*>("H"), &obj1);
-#endif
+	            _POPPLER_FREE(obj1);
+                    _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "H");
             }
             if (!obj1.isInt()) {
 	            goto err2;
             }
             maskHeight = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("BitsPerComponent"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("BitsPerComponent"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "BitsPerComponent");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                    obj1 = maskDict->lookup(const_cast<char*>("BPC"));
-#else
-        	    obj1.free();
-	            maskDict->lookup(const_cast<char*>("BPC"), &obj1);
-#endif
+                    _POPPLER_FREE(obj1);
+                    _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "BPC");
             }
             if (!obj1.isInt()) {
 	            goto err2;
             }
             int maskBits = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Interpolate"));
-#else
-            obj1.free();
-	    maskDict->lookup("Interpolate", &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Interpolate");
 	    if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-              obj1 = maskDict->lookup(const_cast<char*>("I"));
-#else
-	      obj1.free();
-	      maskDict->lookup("I", &obj1);
-#endif
+	      _POPPLER_FREE(obj1);
+              _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "I");
 	    }
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
 	      maskInterpolate = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("ColorSpace"));
-#else
-	    obj1.free();
-            maskDict->lookup(const_cast<char*>("ColorSpace"), &obj1);
-#endif
+	    _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "ColorSpace");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                    obj1 = maskDict->lookup(const_cast<char*>("CS"));
-#else
-	            obj1.free();
-	            maskDict->lookup(const_cast<char*>("CS"), &obj1);
-#endif
+	            _POPPLER_FREE(obj1);
+                    _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "CS");
             }
             if (obj1.isName()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	            obj2 = res->lookupColorSpace(obj1.getName());
-#else
-	            res->lookupColorSpace(obj1.getName(), &obj2);
-#endif
+	            _POPPLER_CALL_ARGS(obj2, res->lookupColorSpace, obj1.getName());
 	            if (!obj2.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
+	                _POPPLER_FREE(obj1);
                         obj1 = std::move(obj2);
-#else
-	                obj1.free();
-    	            obj1 = obj2;
-#endif
 	            } else {
-#if !defined(POPPLER_NEW_OBJECT_API)
-	                obj2.free();
-#endif
+	                _POPPLER_FREE(obj2);
 	            }
             }
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
@@ -3195,29 +2838,17 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
 #else
             GfxColorSpace *maskColorSpace = GfxColorSpace::parse(&obj1, NULL);
 #endif
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj1.free();
-#endif
+            _POPPLER_FREE(obj1);
             if (!maskColorSpace || maskColorSpace->getMode() != csDeviceGray) {
                 goto err1;
             }
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Decode"));
-#else
-            maskDict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Decode");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("D"));
-#else
-	            obj1.free();
-    	        maskDict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "D");
             }
             maskColorMap = new GfxImageColorMap(maskBits, &obj1, maskColorSpace);
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj1.free();
-#endif
+            _POPPLER_FREE(obj1);
             if (!maskColorMap->isOk()) {
                 delete maskColorMap;
                 goto err1;
@@ -3228,15 +2859,9 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
             // color key mask
             int i;
             for (i = 0; i < maskObj.arrayGetLength() && i < 2*gfxColorMaxComps; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskObj.arrayGet(i);
-#else
-                maskObj.arrayGet(i, &obj1);
-#endif
+                _POPPLER_CALL_ARGS(obj1, maskObj.arrayGet, i);
                 maskColors[i] = obj1.getInt();
-#if !defined(POPPLER_NEW_OBJECT_API)
-                obj1.free();
-#endif
+                _POPPLER_FREE(obj1);
             }
               haveColorKeyMask = gTrue;
         } else if (maskObj.isStream()) {
@@ -3246,111 +2871,61 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
             }
             maskStr = maskObj.getStream();
             maskDict = maskObj.streamGetDict();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Width"));
-#else
-            maskDict->lookup(const_cast<char*>("Width"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Width");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("W"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("W"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "W");
             }
             if (!obj1.isInt()) {
                 goto err2;
             }
             maskWidth = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Height"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("Height"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Height");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("H"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("H"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "H");
             }
             if (!obj1.isInt()) {
                 goto err2;
             }
             maskHeight = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("ImageMask"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("ImageMask"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "ImageMask");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("IM"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("IM"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "IM");
             }
             if (!obj1.isBool() || !obj1.getBool()) {
                 goto err2;
             }
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup("Interpolate");
-#else
-            obj1.free();
-	    maskDict->lookup("Interpolate", &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Interpolate");
 	    if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	      obj1 = maskDict->lookup("I");
-#else
-	      obj1.free();
-	      maskDict->lookup("I", &obj1);
-#endif
+	      _POPPLER_FREE(obj1);
+	      _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "I");
 	    }
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
 	      maskInterpolate = gFalse;
-#if !defined(POPPLER_NEW_OBJECT_API)
-	    obj1.free();
-#endif
+	    _POPPLER_FREE(obj1);
             maskInvert = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Decode"));
-#else
-            maskDict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Decode");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("D"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "D");
             }
             if (obj1.isArray()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj2 = obj1.arrayGet(0);
-#else
-                obj1.arrayGet(0, &obj2);
-#endif
+                _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, 0);
                 if (obj2.isInt() && obj2.getInt() == 1) {
                     maskInvert = gTrue;
                 }
-#if !defined(POPPLER_NEW_OBJECT_API)
-                obj2.free();
-#endif
+                _POPPLER_FREE(obj2);
             } else if (!obj1.isNull()) {
                 goto err2;
             }
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj1.free();
-#endif
+            _POPPLER_FREE(obj1);
             haveExplicitMask = gTrue;
         }
         
@@ -3368,18 +2943,14 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         }
         delete colorMap;
         
-#if !defined(POPPLER_NEW_OBJECT_API)
-        maskObj.free();
-        smaskObj.free();
-#endif
+        _POPPLER_FREE(maskObj);
+        _POPPLER_FREE(smaskObj);
     }
 
     return;
 
  err2:
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
  err1:
     error(errSyntaxError, getPos(), "Bad image parameters");
 }
@@ -3404,97 +2975,52 @@ void PdfParser::doForm(Object *str) {
   dict = str->streamGetDict();
 
   // check form type
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("FormType"));
-#else
-  dict->lookup(const_cast<char*>("FormType"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "FormType");
   if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {
     error(errSyntaxError, getPos(), "Unknown form type");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get bounding box
-#if defined(POPPLER_NEW_OBJECT_API)
-  bboxObj = dict->lookup(const_cast<char*>("BBox"));
-#else
-  dict->lookup(const_cast<char*>("BBox"), &bboxObj);
-#endif
+  _POPPLER_CALL_ARGS(bboxObj, dict->lookup, "BBox");
   if (!bboxObj.isArray()) {
-#if !defined(POPPLER_NEW_OBJECT_API)
-    bboxObj.free();
-#endif
+    _POPPLER_FREE(bboxObj);
     error(errSyntaxError, getPos(), "Bad form bounding box");
     return;
   }
   for (i = 0; i < 4; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = bboxObj.arrayGet(i);
-#else
-    bboxObj.arrayGet(i, &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, bboxObj.arrayGet, i);
     bbox[i] = obj1.getNum();
-#if defined(POPPLER_NEW_OBJECT_API)
-  }
-#else
-    obj1.free();
+    _POPPLER_FREE(obj1);
   }
-  bboxObj.free();
-#endif
+  _POPPLER_FREE(bboxObj);
 
   // get matrix
-#if defined(POPPLER_NEW_OBJECT_API)
-  matrixObj = dict->lookup(const_cast<char*>("Matrix"));
-#else
-  dict->lookup(const_cast<char*>("Matrix"), &matrixObj);
-#endif
+  _POPPLER_CALL_ARGS(matrixObj, dict->lookup, "Matrix");
   if (matrixObj.isArray()) {
     for (i = 0; i < 6; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj1 = matrixObj.arrayGet(i);
-#else
-      matrixObj.arrayGet(i, &obj1);
-#endif
+      _POPPLER_CALL_ARGS(obj1, matrixObj.arrayGet, i);
       m[i] = obj1.getNum();
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj1.free();
-#endif
+      _POPPLER_FREE(obj1);
     }
   } else {
     m[0] = 1; m[1] = 0;
     m[2] = 0; m[3] = 1;
     m[4] = 0; m[5] = 0;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  matrixObj.free();
-#endif
+  _POPPLER_FREE(matrixObj);
 
   // get resources
-#if defined(POPPLER_NEW_OBJECT_API)
-  resObj = dict->lookup(const_cast<char*>("Resources"));
-#else
-  dict->lookup(const_cast<char*>("Resources"), &resObj);
-#endif
+  _POPPLER_CALL_ARGS(resObj, dict->lookup, "Resources");
   resDict = resObj.isDict() ? resObj.getDict() : (Dict *)NULL;
 
   // check for a transparency group
   transpGroup = isolated = knockout = gFalse;
   blendingColorSpace = NULL;
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj1 = dict->lookup(const_cast<char*>("Group"))).isDict()) {
-    if ((obj2 = obj1.dictLookup(const_cast<char*>("S"))).isName(const_cast<char*>("Transparency"))) {
-#else
-  if (dict->lookup(const_cast<char*>("Group"), &obj1)->isDict()) {
-    if (obj1.dictLookup(const_cast<char*>("S"), &obj2)->isName(const_cast<char*>("Transparency"))) {
-#endif
+  if (_POPPLER_CALL_ARGS_DEREF(obj1, dict->lookup, "Group").isDict()) {
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "S").isName("Transparency")) {
       transpGroup = gTrue;
-#if defined(POPPLER_NEW_OBJECT_API)
-      if (!((obj3 = obj1.dictLookup(const_cast<char*>("CS"))).isNull())) {
-#else
-      if (!obj1.dictLookup(const_cast<char*>("CS"), &obj3)->isNull()) {
-#endif
+      if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "CS").isNull()) {
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
 	blendingColorSpace = GfxColorSpace::parse(NULL, &obj3, NULL, NULL);
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
@@ -3503,32 +3029,19 @@ void PdfParser::doForm(Object *str) {
 	blendingColorSpace = GfxColorSpace::parse(&obj3, NULL);
 #endif
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj1.dictLookup(const_cast<char*>("I"))).isBool()) {
-#else
-      obj3.free();
-      if (obj1.dictLookup(const_cast<char*>("I"), &obj3)->isBool()) {
-#endif
+      _POPPLER_FREE(obj3);
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "I").isBool()) {
 	isolated = obj3.getBool();
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj1.dictLookup(const_cast<char*>("K"))).isBool()) {
-#else
-      obj3.free();
-      if (obj1.dictLookup(const_cast<char*>("K"), &obj3)->isBool()) {
-#endif
+      _POPPLER_FREE(obj3);
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "K").isBool()) {
 	knockout = obj3.getBool();
       }
-#if defined(POPPLER_NEW_OBJECT_API)
+      _POPPLER_FREE(obj3);
     }
+    _POPPLER_FREE(obj2);
   }
-#else
-      obj3.free();
-    }
-    obj2.free();
-  }
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // draw it
   ++formDepth;
@@ -3539,9 +3052,7 @@ void PdfParser::doForm(Object *str) {
   if (blendingColorSpace) {
     delete blendingColorSpace;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  resObj.free();
-#endif
+  _POPPLER_FREE(resObj);
 }
 
 void PdfParser::doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
@@ -3670,17 +3181,14 @@ Stream *PdfParser::buildImageStream() {
   // build dictionary
 #if defined(POPPLER_NEW_OBJECT_API)
   dict = Object(new Dict(xref));
-  obj = parser->getObj();
 #else
   dict.initDict(xref);
-  parser->getObj(&obj);
 #endif
+  _POPPLER_CALL(obj, parser->getObj);
   while (!obj.isCmd(const_cast<char*>("ID")) && !obj.isEOF()) {
     if (!obj.isName()) {
       error(errSyntaxError, getPos(), "Inline image dictionary key must be a name object");
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj.free();
-#endif
+      _POPPLER_FREE(obj);
     } else {
       Object obj2;
       _POPPLER_CALL(obj2, parser->getObj);
@@ -3696,15 +3204,11 @@ Stream *PdfParser::buildImageStream() {
   }
   if (obj.isEOF()) {
     error(errSyntaxError, getPos(), "End of file in inline image");
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj.free();
-    dict.free();
-#endif
+    _POPPLER_FREE(obj);
+    _POPPLER_FREE(dict);
     return NULL;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
 
   // make stream
 #if defined(POPPLER_NEW_OBJECT_API)
diff --git a/src/extension/internal/pdfinput/poppler-transition-api.h b/src/extension/internal/pdfinput/poppler-transition-api.h
index 898e64bf2b..6ed911b04b 100644
--- a/src/extension/internal/pdfinput/poppler-transition-api.h
+++ b/src/extension/internal/pdfinput/poppler-transition-api.h
@@ -22,10 +22,12 @@
 #define _POPPLER_FREE(obj)
 #define _POPPLER_CALL(ret, func) (ret = func())
 #define _POPPLER_CALL_ARGS(ret, func, ...) (ret = func(__VA_ARGS__))
+#define _POPPLER_CALL_ARGS_DEREF _POPPLER_CALL_ARGS
 #else
 #define _POPPLER_FREE(obj) (obj).free()
 #define _POPPLER_CALL(ret, func) (*func(&ret))
-#define _POPPLER_CALL_ARGS(ret, func, ...) (*func(__VA_ARGS__, &ret))
+#define _POPPLER_CALL_ARGS(ret, func, ...) (func(__VA_ARGS__, &ret))
+#define _POPPLER_CALL_ARGS_DEREF(...) (*_POPPLER_CALL_ARGS(__VA_ARGS__))
 #endif
 
 #if POPPLER_CHECK_VERSION(0, 29, 0)
-- 
2.18.1

From d047859d90cef3784e2d13e40887a70d8d517897 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bart=C5=82omiej=20Szczepaniak?=
 <szczepaniak.bartek@gmail.com>
Date: Tue, 6 Nov 2018 07:41:40 +0000
Subject: [PATCH] fix poppler 0.71.0 build.

---
 src/extension/internal/pdfinput/poppler-transition-api.h | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/extension/internal/pdfinput/poppler-transition-api.h b/src/extension/internal/pdfinput/poppler-transition-api.h
index 6ed911b04b..4437052593 100644
--- a/src/extension/internal/pdfinput/poppler-transition-api.h
+++ b/src/extension/internal/pdfinput/poppler-transition-api.h
@@ -3,6 +3,12 @@
 
 #include <glib/poppler-features.h>
 
+#if POPPLER_CHECK_VERSION(0,71,0)
+typedef bool GBool;
+#define gTrue true
+#define gFalse false
+#endif
+
 #if POPPLER_CHECK_VERSION(0,70,0)
 #define _POPPLER_CONST const
 #else
-- 
2.18.1

From b3d59cc8106da3bf6020a6c47eeb3b8a7bbae1a9 Mon Sep 17 00:00:00 2001
From: Thomas Holder <thomas@thomas-holder.de>
Date: Sun, 9 Dec 2018 10:21:34 +0100
Subject: [PATCH] fix poppler 0.72.0 build

---
 src/extension/internal/pdfinput/pdf-parser.h             | 1 -
 src/extension/internal/pdfinput/poppler-transition-api.h | 4 ++++
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/extension/internal/pdfinput/pdf-parser.h b/src/extension/internal/pdfinput/pdf-parser.h
index 2d4441a22c..31c84d51bb 100644
--- a/src/extension/internal/pdfinput/pdf-parser.h
+++ b/src/extension/internal/pdfinput/pdf-parser.h
@@ -37,7 +37,6 @@ namespace Inkscape {
 using Inkscape::Extension::Internal::SvgBuilder;
 
 #include "glib/poppler-features.h"
-#include "goo/gtypes.h"
 #include "Object.h"
 
 class GooString;
diff --git a/src/extension/internal/pdfinput/poppler-transition-api.h b/src/extension/internal/pdfinput/poppler-transition-api.h
index 5141bf8a73..61a15083a0 100644
--- a/src/extension/internal/pdfinput/poppler-transition-api.h
+++ b/src/extension/internal/pdfinput/poppler-transition-api.h
@@ -14,6 +14,10 @@
 
 #include <glib/poppler-features.h>
 
+#if POPPLER_CHECK_VERSION(0, 72, 0)
+#define getCString c_str
+#endif
+
 #if POPPLER_CHECK_VERSION(0,71,0)
 typedef bool GBool;
 #define gTrue true
-- 
2.18.1

